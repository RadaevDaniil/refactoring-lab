# Лабораторная работа: Рефакторинг и Code Smells

## Описание
Рефакторинг кода обработки заказов (order_processing.py) для улучшения читаемости и поддерживаемости.

## Цель
- Найти code smells в существующем коде
- Применить рефакторинг без изменения поведения
- Убедиться, что тесты продолжают проходить
- Улучшить структуру и читаемость кода

## Технологии
- Python 3.12
- pytest для тестирования
- Принципы DRY, KISS, SOLID

## Структура проекта
```
refactoring-lab/
├── order_processing.py              # Исходный код (до рефакторинга)
├── order_processing_refactored.py   # Код после рефакторинга
├── test_order_processing.py         # Тесты для исходного кода
├── test_order_processing_refactored.py # Тесты для рефакторенного кода
├── requirements.txt                 # Зависимости
└── README.md                        # Документация
```

## Анализ проблем в исходном коде

### Найденные code smells:

1. **Длинный метод (Long Method)**
   - Функция `process_checkout()` содержит 61 строку
   - Выполняет слишком много задач: парсинг, валидация, расчеты, форматирование

2. **Магические числа (Magic Numbers)**
   - `0.10`, `0.20`, `0.05`, `0.21` - проценты скидок и налога
   - `200`, `50`, `10`, `100` - пороговые значения

3. **Сложные условия (Complex Conditional)**
   - Вложенные if-elif для расчета скидок
   - Логика скидок перемешана с основной логикой

4. **Нарушение SRP (Single Responsibility Principle)**
   - Одна функция отвечает за парсинг, валидацию, расчеты и форматирование

5. **Жестко закодированные строки (Hardcoded Strings)**
   - `"SAVE10"`, `"SAVE20"`, `"VIP"` - коды купонов
   - `"USD"` - валюта по умолчанию

6. **Повторяющаяся валидация**
   - Несколько проверок на None/пустоту
   - Похожие проверки для разных полей

7. **Неидиоматичный Python**
   - `type(items) is not list` вместо `isinstance(items, list)`
   - Ручной цикл для суммирования вместо `sum()`

## Примененные рефакторинги

### 1. Extract Function (Выделение функции)
Разделили монолитную функцию на 8 маленьких:

1. `parse_request()` - извлечение данных из запроса
2. `validate_request()` - базовая валидация входных данных
3. `validate_items()` - проверка элементов заказа
4. `calculate_subtotal()` - расчет общей суммы
5. `calculate_discount()` - расчет скидки по купону
6. `calculate_tax()` - расчет налога
7. `generate_order_id()` - генерация ID заказа
8. `process_checkout()` - основная функция (теперь только координирует)

### 2. Introduce Constant (Введение констант)
```python
DEFAULT_CURRENCY = "USD"
TAX_RATE = 0.21
COUPON_DISCOUNTS = {
    "SAVE10": 0.10,
    "SAVE20": {"threshold": 200, "high": 0.20, "low": 0.05},
    "VIP": {"default": 50, "under_100": 10}
}
```

### 3. Replace Magic Literal (Замена магических литералов)
- Использование констант вместо жестко закодированных значений
- Централизованное хранение конфигурации скидок

### 4. Simplify Conditional (Упрощение условий)
- Логика скидок вынесена в отдельную функцию
- Использование словаря для хранения правил скидок

### 5. Use Pythonic Constructs (Использование идиоматичного Python)
- `isinstance(items, list)` вместо `type(items) is not list`
- `sum()` с генератором вместо ручного цикла
- `max(subtotal - discount, 0)` вместо проверки if
- `currency or DEFAULT_CURRENCY` вместо явной проверки None

### 6. Improve Readability (Улучшение читаемости)
- Функции следуют порядку выполнения
- Код читается как сценарий сверху вниз
- Ясные имена функций и переменных

## Сравнение до и после

### До рефакторинга:
```python
# Функция process_checkout() - 61 строка
# Смешение парсинга, валидации, расчетов
# Магические числа разбросаны по коду
# Сложные вложенные условия
```

### После рефакторинга:
```python
# Основная функция - 23 строки
def process_checkout(request):
    # 1. Парсинг
    user_id, items, coupon, currency = parse_request(request)
    
    # 2. Валидация
    currency = validate_request(user_id, items, currency)
    validate_items(items)
    
    # 3. Расчеты
    subtotal = calculate_subtotal(items)
    discount = calculate_discount(coupon, subtotal)
    total_after_discount = max(subtotal - discount, 0)
    tax = calculate_tax(total_after_discount)
    total = total_after_discount + tax
    
    # 4. Формирование результата
    order_id = generate_order_id(user_id, len(items))
    
    return {
        "order_id": order_id,
        "user_id": user_id,
        "currency": currency,
        "subtotal": subtotal,
        "discount": discount,
        "tax": tax,
        "total": total,
        "items_count": len(items),
    }
```

## Преимущества рефакторинга

1. **Читаемость**
   - Код читается как последовательность шагов
   - Каждая функция имеет одну четкую задачу
   - Имена функций объясняют их назначение

2. **Поддерживаемость**
   - Легко модифицировать отдельные части
   - Добавление новой скидки - изменение только словаря `COUPON_DISCOUNTS`
   - Изменение ставки налога - изменение одной константы

3. **Тестируемость**
   - Каждая функция может тестироваться изолированно
   - Легко создавать тесты для edge cases
   - Меньшие функции = проще тесты

4. **Повторное использование**
   - Функции можно использовать в других частях системы
   - `calculate_tax()` может использоваться отдельно
   - `validate_items()` применима для других проверок

5. **Расширяемость**
   - Легко добавить новые типы скидок
   - Просто изменить правила валидации
   - Гибкая конфигурация через константы

## Запуск и тестирование

### Установка зависимостей:
```bash
pip install -r requirements.txt
```

### Тестирование исходного кода:
```bash
python -m pytest test_order_processing.py -v
```

### Тестирование рефакторенного кода:
```bash
python -m pytest test_order_processing_refactored.py -v
```

### Все тесты:
```bash
python -m pytest test_*.py -v
```

## Тестовое покрытие

### Тесты для исходного кода:
1. Корректная обработка без купона
2. Применение купона SAVE10
3. Применение купона SAVE20
4. Обработка неизвестного купона

### Дополнительные тесты для рефакторенного кода:
5. Валидация отсутствующего user_id
6. Валидация отсутствующих items
7. Валидация некорректного типа items
8. Валидация пустого списка items
9. Валидация item без price/qty
10. Валидация неположительной цены
11. Валидация неположительного количества

Все тесты проходят успешно, что подтверждает сохранение поведения после рефакторинга.

## Заключение

Рефакторинг позволил:
- ✅ Сократить основную функцию с 61 до 23 строк
- ✅ Убрать магические числа и жестко закодированные строки
- ✅ Упростить сложные условные конструкции
- ✅ Улучшить читаемость и поддерживаемость
- ✅ Сохранить полную функциональность
- ✅ Пройти все существующие и новые тесты

Код стал более чистым, модульным и готовым к дальнейшему развитию.